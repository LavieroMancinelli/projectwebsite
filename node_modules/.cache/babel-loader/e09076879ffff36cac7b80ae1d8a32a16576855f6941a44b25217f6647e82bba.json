{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Laviero\\\\Documents\\\\Weather\\\\src\\\\pages\\\\Maze.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst generate = (dim, animateWallStep, setIsGenerating, setHasGenerated) => {\n  setHasGenerated(false);\n  // generate board\n  let boardDim = dim * 2 + 1;\n  let cycleDelay = boardDim >= 20 ? 1 : 20;\n  let board = [];\n  let walls = [];\n  for (let i = 0; i < boardDim; i++) {\n    let row = [];\n    for (let j = 0; j < boardDim; j++) {\n      if (i === 0 || j === 0 || i === boardDim - 1 || j === boardDim - 1) {\n        row.push([1, new Set([[i, j]])]);\n      } // walls on edges\n      else if (i % 2 === 0 || j % 2 === 0) {\n        row.push([1, new Set([[i, j]])]);\n        if (!(i % 2 === 0 && j % 2 === 0)) {\n          // add to walls if seperates two open spaces\n          walls.push([i, j]);\n        }\n      } // walls on even squares\n      else {\n        row.push([0, new Set([[i, j]])]);\n      }\n      ;\n    }\n    board.push(row);\n  }\n\n  // entrance and exit\n  board[0][1][0] = 0;\n  board[boardDim - 1][boardDim - 2][0] = 0;\n\n  // NEED TO NOT STORE SETS ON CELLS BECAUSE WHEN UPDATE ONE NEED TO UPDATE ALL CONNECTED SETS\n\n  /*\r\n  // fisher-yates shuffle wall array\r\n  for (let i = walls.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [walls[i], walls[j]] = [walls[j], walls[i]]; // Swap elements\r\n  }\r\n      */\n\n  let wallI = 0;\n  const processWall = () => {\n    if (wallI < walls.length) {\n      let i = walls[wallI][0],\n        j = walls[wallI][1];\n      let adj = [];\n      if (i - 1 > 0 && board[i - 1][j][0] == 0) adj.push([i - 1, j]); // add adj\n      if (j - 1 > 0 && board[i][j - 1][0] == 0) adj.push([i, j - 1]);\n      if (i + 1 < boardDim - 1 && board[i + 1][j][0] == 0) adj.push([i + 1, j]);\n      if (j + 1 < boardDim - 1 && board[i][j + 1][0] == 0) adj.push([i, j + 1]);\n      //console.log(adj.length);\n      let duplicate = false; // verify adj spaces no duplicate sets\n      for (let adjI = 0; adjI < adj.length; adjI++) {\n        for (let adjJ = 0; adjJ < adj.length; adjJ++) {\n          let iI = adj[adjI][0],\n            iJ = adj[adjI][1];\n          let jI = adj[adjJ][0],\n            jJ = adj[adjJ][1];\n          if (adjI != adjJ && board[iI][iJ][1] == board[jI][jJ][1]) {\n            duplicate = true;\n            //console.log(\"DENIED at\", i, \",\", j);\n            break;\n          }\n        }\n      }\n      if (!duplicate && adj.length > 0) {\n        // if no adj spaces have dup sets\n        //console.log(\"passed at\", i, \",\", j);\n        board[i][j][0] = 0; // make this wall a space\n        let sumSet = new Set();\n        sumSet.add([i, j]); // add wall to adj spaces' sets\n        for (let adjI = 0; adjI < adj.length; adjI++) {\n          // combine sets of adj spaces into sumSet\n          let curI = adj[adjI][0],\n            curJ = adj[adjI][1];\n          sumSet = sumSet.union(board[curI][curJ][1]);\n        }\n        for (let item of sumSet) {\n          // set sets of cells in sumSet to sumSet\n          let curI = item[0],\n            curJ = item[1];\n          board[curI][curJ][1] = sumSet;\n        }\n      }\n      wallI++;\n      animateWallStep(board);\n      setTimeout(processWall, cycleDelay);\n    }\n    if (wallI >= walls.length) {\n      setIsGenerating(false);\n      setHasGenerated(true);\n      animateWallStep(board);\n    }\n  };\n  processWall();\n\n  //console.log(\"Final wallI\", wallI);\n  return board;\n};\nconst Maze = ({\n  board,\n  playerPos,\n  setPlayerPos,\n  setWin,\n  setGameStarted,\n  gameStarted\n}) => {\n  _s();\n  const boardSize = board.length;\n  const cellSize = `${600 / boardSize}px`; //`${60 / boardSize}vh`;\n\n  //const [playerPos, setPlayerPos] = useState([1,1])\n\n  const movePlayer = e => {\n    setPlayerPos(prevPos => {\n      if (prevPos[0] === -1 && prevPos[1] === -1) return prevPos;\n      let newPos = {\n        ...prevPos\n      };\n      if (e.key === 'ArrowUp' || e.key === 'w') {\n        newPos[0] = Math.max(prevPos[0] - 1, 0);\n      } else if (e.key === 'ArrowDown' || e.key === 's') {\n        newPos[0] = Math.min(prevPos[0] + 1, boardSize - 1);\n      } else if (e.key === 'ArrowLeft' || e.key === 'a') {\n        newPos[1] = Math.max(prevPos[1] - 1, 0);\n      } else if (e.key === 'ArrowRight' || e.key === 'd') {\n        newPos[1] = Math.min(prevPos[1] + 1, boardSize - 1);\n      }\n\n      // prevent move into wall\n      if (board[newPos[0]][newPos[1]][0] === 1 && (newPos != [0, 1] || newPos != [boardSize - 1, boardSize - 2])) {\n        return prevPos;\n      }\n      // detect win\n      if (newPos[0] === boardSize - 1 && newPos[1] === boardSize - 2) {\n        setWin(true);\n        setGameStarted(false);\n        console.log(\"game won\");\n      }\n      return newPos;\n    });\n  };\n  useEffect(() => {\n    if (gameStarted) window.addEventListener('keydown', movePlayer);else window.removeEventListener('keydown', movePlayer);\n    return () => window.removeEventListener('keydown', movePlayer);\n  }, [gameStarted, board]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: board.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex'\n      },\n      children: row.map((cell, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          width: cellSize,\n          height: cellSize,\n          backgroundColor: playerPos[0] === rowIndex && playerPos[1] === colIndex ? 'red' : cell[0] === 2 ? 'green' : cell[0] === 3 ? 'blue' : cell[0] === 1 ? 'black' : 'white'\n          //border: cell === 1 ? '1px solid black' : '1px solid gray'\n        }\n      }, colIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 151,\n        columnNumber: 25\n      }, this))\n    }, rowIndex, false, {\n      fileName: _jsxFileName,\n      lineNumber: 149,\n      columnNumber: 17\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 147,\n    columnNumber: 9\n  }, this);\n};\n_s(Maze, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Maze;\nconst MazeApp = () => {\n  _s2();\n  const [board, setBoard] = useState([]);\n  const [playerPos, setPlayerPos] = useState([0, 1]);\n  const [win, setWin] = useState(false);\n  const [dim, setDim] = useState(10);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [hasGenerated, setHasGenerated] = useState(false);\n  const [gameStarted, setGameStarted] = useState(false);\n  const [solving, setSolving] = useState(false);\n  const animateWallStep = updatedBoard => {\n    setBoard([...updatedBoard]);\n  };\n  const handleGenerate = () => {\n    setIsGenerating(true);\n    const newBoard = generate(dim, animateWallStep, setIsGenerating, setHasGenerated);\n    setBoard(newBoard);\n    setPlayerPos([-1, -1]);\n    setWin(false);\n  };\n  const handleStartGame = () => {\n    setPlayerPos([0, 1]);\n    setWin(false);\n    setGameStarted(true);\n  };\n  const handleAutoSolve = () => {\n    autoSolve();\n  };\n  const autoSolve = () => {\n    setSolving(true);\n    let path = [[0, 1]];\n    let visited = new Set();\n    const solveStep = () => {\n      if (path.length > 0) {\n        // get most recent space\n        let [row, col] = path[path.length - 1];\n        // color explored spaces greem\n        board[row][col][0] = 2;\n        setBoard([...board]);\n        visited.add([row, col]);\n\n        // if reach end, color this path blue\n        if (row == board.length - 1 && col == board.length - 2) {\n          console.log(\"autosolved\");\n          path.forEach(([r, c]) => {\n            board[r][c][0] = 3;\n          });\n          setSolving(false);\n          setWin(true);\n          setGameStarted(false);\n          return;\n        }\n        let stepAdded = false;\n        const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n        // check each direction (avoid double back)\n        for (let [dRow, dCol] of directions) {\n          let newRow = row + dRow;\n          let newCol = col + dCol;\n          if (newRow >= 0 && newRow < board.length && newCol >= 0 && newCol < board.length && board[newRow][newCol][0] === 0 && !visited.has([newRow, newCol])) {\n            path.push([newRow, newCol]);\n            stepAdded = true;\n            break;\n          }\n        }\n        // backtrack if couldn't move forward\n        if (!stepAdded) {\n          path.pop();\n          return solveStep();\n        }\n        setTimeout(solveStep, 10);\n      } else {\n        setSolving(false);\n      }\n    };\n    solveStep();\n  };\n  useEffect(() => {\n    const disableArrowKeys = e => {\n      if ([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].includes(e.key)) {\n        e.preventDefault();\n      }\n    };\n    if (gameStarted) {\n      window.addEventListener(\"keydown\", disableArrowKeys);\n    } else {\n      window.removeEventListener(\"keydown\", disableArrowKeys);\n    }\n    return () => {\n      window.removeEventListener(\"keydown\", disableArrowKeys);\n    };\n  }, [gameStarted]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mazeBox\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Maze Generator\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 278,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Using Randomized Kruskal's Algorithm\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 279,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"genAndDimSlider\",\n        children: gameStarted ? /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex',\n            flexDirection: 'row',\n            alignItems: 'center'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"autoSolve\",\n            onClick: handleAutoSolve,\n            children: \"Auto Solve\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 283,\n            columnNumber: 29\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            children: \"Use arrow keys to move player to bottom right\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 284,\n            columnNumber: 29\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 282,\n          columnNumber: 25\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            display: 'flex',\n            flexDirection: 'row',\n            alignItems: 'center'\n          },\n          children: [isGenerating ?\n          /*#__PURE__*/\n          /*<button className=\"speedUp\" onClick={handleSpeedUp}>Speed Up</button>*/\n          _jsxDEV(\"div\", {\n            className: \"genText\",\n            children: [\"Generating maze of size: \", dim, \"...\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 290,\n            columnNumber: 33\n          }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              display: 'flex',\n              flexDirection: 'row',\n              alignItems: 'center'\n            },\n            children: [/*#__PURE__*/_jsxDEV(\"button\", {\n              className: \"startMaze\",\n              onClick: handleGenerate,\n              children: \"Generate Maze\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 293,\n              columnNumber: 37\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"dimSliderBox\",\n              children: [/*#__PURE__*/_jsxDEV(\"input\", {\n                type: \"range\",\n                id: \"dimSlider\",\n                min: \"1\",\n                max: \"40\",\n                value: dim,\n                onChange: e => setDim(Number(e.target.value))\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 295,\n                columnNumber: 41\n              }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n                htmlFor: \"dimSlider\",\n                children: [\"Size: \", dim]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 303,\n                columnNumber: 41\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 294,\n              columnNumber: 37\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 292,\n            columnNumber: 33\n          }, this), hasGenerated && !win && /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"startGame\",\n            onClick: handleStartGame,\n            children: \"Start Game\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 309,\n            columnNumber: 33\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 287,\n          columnNumber: 25\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 280,\n        columnNumber: 17\n      }, this), win && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"winMessage\",\n        children: \"Maze solved!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 315,\n        columnNumber: 25\n      }, this), /*#__PURE__*/_jsxDEV(Maze, {\n        board: board,\n        playerPos: playerPos,\n        setPlayerPos: setPlayerPos,\n        setWin: setWin,\n        setGameStarted: setGameStarted,\n        gameStarted: gameStarted\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"kruskalText\",\n        children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n          children: \"About Randomized Kruskal's Algorithm\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 319,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n          children: [\"The Randomized Kruskal's Algorithm is a variation of Kruskal's\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 321,\n            columnNumber: 25\n          }, this), \"Algorithm to find a minimum spanning tree of a graph.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 322,\n            columnNumber: 25\n          }, this), \"Kruskal's Algorithm is essentially:\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 323,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 324,\n            columnNumber: 25\n          }, this), \"       1. Initialize a forest of single-vertex trees for each vertex\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 325,\n            columnNumber: 25\n          }, this), \"          in input graph.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 326,\n            columnNumber: 25\n          }, this), \"       2. Sort edges of the input graph by weight\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 327,\n            columnNumber: 25\n          }, this), \"       3. For each edge (in order of weight):\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 328,\n            columnNumber: 25\n          }, this), \"           - If adding the edge would not create a cycle:\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 329,\n            columnNumber: 25\n          }, this), \"              - Add the edge to the forest and merge the trees it connects\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 330,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 331,\n            columnNumber: 25\n          }, this), \"The version of Kruskal's Algorithm used to create this maze does not use\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 332,\n            columnNumber: 25\n          }, this), \"weights but instead applies a random order. randomized version applied to this maze goes like this:\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 333,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 334,\n            columnNumber: 25\n          }, this), \"       1. Initialize the walls to separate single square cells.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 335,\n            columnNumber: 25\n          }, this), \"       2. Add all the walls to a single set and shuffle it.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 336,\n            columnNumber: 25\n          }, this), \"          Make a set for each cell containing only that cell.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 337,\n            columnNumber: 25\n          }, this), \"       3. For each wall in the set of walls:\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 338,\n            columnNumber: 25\n          }, this), \"           - If the sets of adjacent spaces do not overlap:\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 339,\n            columnNumber: 25\n          }, this), \"              - Make the wall a space and combine the sets of adjacent\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 340,\n            columnNumber: 25\n          }, this), \"                spaces including the space just created\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 341,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 342,\n            columnNumber: 25\n          }, this), \"In this application, the initial constuction of walls creates a graph\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 343,\n            columnNumber: 25\n          }, this), \"of spaces (nodes) which can be connected by edges (walls). Each square's\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 344,\n            columnNumber: 25\n          }, this), \"set represents the tree of spaces it is connected to. When we remove a wall,\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 345,\n            columnNumber: 25\n          }, this), \"we are adding an edge between the sets of adjacent spaces. So by only\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 346,\n            columnNumber: 25\n          }, this), \"removing a wall when the adjacent sets do not overlap, we are connecting\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 347,\n            columnNumber: 25\n          }, this), \"portions of the maze while guaranteeing that there are no cycles. Once all\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 348,\n            columnNumber: 25\n          }, this), \"the walls that can be removed have been, every edge that could have\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 349,\n            columnNumber: 25\n          }, this), \"been added without creating a cycle was added and now there is one set\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 350,\n            columnNumber: 25\n          }, this), \"that connects every space. Thus, we are left with a connected graph with no\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 351,\n            columnNumber: 25\n          }, this), \"cycles or a spanning tree. In other words, any space can be reached starting\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 352,\n            columnNumber: 25\n          }, this), \"from any other space, including the end square from the beginning square.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 320,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 277,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 276,\n    columnNumber: 9\n  }, this);\n};\n_s2(MazeApp, \"EhAbWpk82h802XT0l327zqeV6oA=\");\n_c2 = MazeApp;\nexport default MazeApp;\nvar _c, _c2;\n$RefreshReg$(_c, \"Maze\");\n$RefreshReg$(_c2, \"MazeApp\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","generate","dim","animateWallStep","setIsGenerating","setHasGenerated","boardDim","cycleDelay","board","walls","i","row","j","push","Set","wallI","processWall","length","adj","duplicate","adjI","adjJ","iI","iJ","jI","jJ","sumSet","add","curI","curJ","union","item","setTimeout","Maze","playerPos","setPlayerPos","setWin","setGameStarted","gameStarted","_s","boardSize","cellSize","movePlayer","e","prevPos","newPos","key","Math","max","min","console","log","window","addEventListener","removeEventListener","children","map","rowIndex","style","display","cell","colIndex","width","height","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","MazeApp","_s2","setBoard","win","setDim","isGenerating","hasGenerated","solving","setSolving","updatedBoard","handleGenerate","newBoard","handleStartGame","handleAutoSolve","autoSolve","path","visited","solveStep","col","forEach","r","c","stepAdded","directions","dRow","dCol","newRow","newCol","has","pop","disableArrowKeys","includes","preventDefault","className","flexDirection","alignItems","onClick","type","id","value","onChange","Number","target","htmlFor","_c2","$RefreshReg$"],"sources":["C:/Users/Laviero/Documents/Weather/src/pages/Maze.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\n\r\nconst generate = (dim, animateWallStep, setIsGenerating, setHasGenerated) => {\r\n    setHasGenerated(false);\r\n    // generate board\r\n    let boardDim = dim * 2 + 1;\r\n    let cycleDelay = boardDim >= 20 ? 1 : 20;\r\n    let board = [];\r\n    let walls = [];\r\n    for (let i = 0; i < boardDim; i++) {\r\n        let row = [];\r\n        for (let j = 0; j < boardDim; j++) {\r\n            if (i === 0 || j === 0 || i === boardDim - 1 || j === boardDim - 1) {\r\n                    row.push([1,new Set([[i,j]])]);\r\n                } // walls on edges\r\n            else if (i % 2 === 0 || j % 2 === 0) {\r\n                row.push([1,new Set([[i,j]])]);\r\n                if (!(i % 2 === 0 && j % 2 === 0)) { // add to walls if seperates two open spaces\r\n                    walls.push([i,j]);\r\n                }\r\n            } // walls on even squares\r\n            else {\r\n                row.push([0,new Set([[i,j]])]);\r\n            };\r\n        }\r\n        board.push(row);\r\n    } \r\n\r\n    // entrance and exit\r\n    board[0][1][0] = 0;\r\n    board[boardDim-1][boardDim-2][0] = 0;\r\n\r\n    // NEED TO NOT STORE SETS ON CELLS BECAUSE WHEN UPDATE ONE NEED TO UPDATE ALL CONNECTED SETS\r\n\r\n    /*\r\n    // fisher-yates shuffle wall array\r\n    for (let i = walls.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [walls[i], walls[j]] = [walls[j], walls[i]]; // Swap elements\r\n    }\r\n        */\r\n\r\n    let wallI = 0;\r\n    const processWall = () =>  {\r\n        if (wallI < walls.length) {\r\n            let i = walls[wallI][0], j = walls[wallI][1];\r\n            let adj = [];\r\n            if (i-1>0 && board[i-1][j][0] == 0) adj.push([i-1,j]); // add adj\r\n            if (j-1>0 && board[i][j-1][0] == 0) adj.push([i,j-1]);\r\n            if (i+1<boardDim-1 && board[i+1][j][0] == 0) adj.push([i+1,j]);\r\n            if (j+1<boardDim-1 && board[i][j+1][0] == 0) adj.push([i,j+1]);\r\n            //console.log(adj.length);\r\n            let duplicate = false; // verify adj spaces no duplicate sets\r\n            for (let adjI = 0; adjI < adj.length; adjI++) {\r\n                for (let adjJ = 0; adjJ < adj.length; adjJ++) {\r\n                    let iI = adj[adjI][0], iJ = adj[adjI][1];\r\n                    let jI = adj[adjJ][0], jJ = adj[adjJ][1];\r\n                    if (adjI != adjJ && board[iI][iJ][1] == board[jI][jJ][1]) {\r\n                        duplicate = true;\r\n                        //console.log(\"DENIED at\", i, \",\", j);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!duplicate && adj.length > 0) { // if no adj spaces have dup sets\r\n                //console.log(\"passed at\", i, \",\", j);\r\n                board[i][j][0] = 0;  // make this wall a space\r\n                let sumSet = new Set();\r\n                sumSet.add([i,j]); // add wall to adj spaces' sets\r\n                for (let adjI = 0; adjI < adj.length; adjI++) { // combine sets of adj spaces into sumSet\r\n                    let curI = adj[adjI][0], curJ = adj[adjI][1];\r\n                    sumSet = sumSet.union(board[curI][curJ][1]);\r\n                }\r\n\r\n                for (let item of sumSet) { // set sets of cells in sumSet to sumSet\r\n                    let curI = item[0], curJ = item[1];\r\n                    board[curI][curJ][1] = sumSet;\r\n                }\r\n            }\r\n            wallI++;\r\n            animateWallStep(board);\r\n            setTimeout(processWall, cycleDelay);\r\n        }\r\n\r\n        if (wallI >= walls.length) {\r\n            setIsGenerating(false);\r\n            setHasGenerated(true);\r\n            animateWallStep(board);\r\n        }\r\n    };\r\n\r\n    processWall();\r\n        \r\n    //console.log(\"Final wallI\", wallI);\r\n    return board;\r\n};\r\n\r\n\r\nconst Maze = ({board, playerPos, setPlayerPos, setWin, setGameStarted, gameStarted}) => {\r\n    const boardSize = board.length;\r\n    const cellSize = `${600/boardSize}px`;//`${60 / boardSize}vh`;\r\n\r\n    //const [playerPos, setPlayerPos] = useState([1,1])\r\n\r\n    const movePlayer = (e) => {\r\n        setPlayerPos((prevPos) => {\r\n            if (prevPos[0] === -1 && prevPos[1] === -1) return prevPos;\r\n            let newPos = { ...prevPos };\r\n            if (e.key === 'ArrowUp' || e.key === 'w') {\r\n                newPos[0] = Math.max(prevPos[0] - 1, 0);\r\n            } else if (e.key === 'ArrowDown' || e.key === 's') {\r\n                newPos[0] = Math.min(prevPos[0] + 1, boardSize - 1);\r\n            } else if (e.key === 'ArrowLeft' || e.key === 'a') {\r\n                newPos[1] = Math.max(prevPos[1] - 1, 0);\r\n            } else if (e.key === 'ArrowRight' || e.key === 'd') {\r\n                newPos[1] = Math.min(prevPos[1] + 1, boardSize - 1);\r\n            }\r\n\r\n            // prevent move into wall\r\n            if (board[newPos[0]][newPos[1]][0] === 1 && \r\n                (newPos != [0,1] || newPos != [boardSize-1,boardSize-2])) {\r\n                return prevPos;\r\n            }\r\n            // detect win\r\n            if (newPos[0] === boardSize-1 && newPos[1] === boardSize-2) {\r\n                setWin(true);\r\n                setGameStarted(false);\r\n                console.log(\"game won\");\r\n            }\r\n            return newPos;\r\n        });\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (gameStarted)\r\n            window.addEventListener('keydown', movePlayer);\r\n        else \r\n            window.removeEventListener('keydown', movePlayer);\r\n        return () => window.removeEventListener('keydown', movePlayer);\r\n    }, [gameStarted, board]);\r\n    \r\n\r\n\r\n\r\n    return (\r\n        <div>\r\n            {board.map((row, rowIndex) => (\r\n                <div key={rowIndex} style={{ display: 'flex' }}>\r\n                    {row.map((cell, colIndex) => (\r\n                        <div key={colIndex} style={{\r\n                            width: cellSize,\r\n                            height: cellSize,\r\n                            backgroundColor:\r\n                                playerPos[0] === rowIndex && playerPos[1] === colIndex\r\n                                    ? 'red'\r\n                                    : cell[0] === 2\r\n                                        ? 'green'\r\n                                        : cell[0] === 3\r\n                                            ? 'blue'\r\n                                            : cell[0] === 1\r\n                                                ? 'black'\r\n                                                : 'white',\r\n                            //border: cell === 1 ? '1px solid black' : '1px solid gray'\r\n                        }}></div>\r\n                    ))}\r\n                </div>\r\n            ))}\r\n        </div>\r\n    )\r\n}\r\n\r\nconst MazeApp = () => {\r\n    const [board, setBoard] = useState([]);\r\n    const [playerPos, setPlayerPos] = useState([0,1]);\r\n    const [win, setWin] = useState(false);\r\n    const [dim, setDim] = useState(10);\r\n    const [isGenerating, setIsGenerating] = useState(false);\r\n    const [hasGenerated, setHasGenerated] = useState(false);\r\n    const [gameStarted, setGameStarted] = useState(false);\r\n    const [solving, setSolving] = useState(false);\r\n\r\n    const animateWallStep = (updatedBoard) => {\r\n        setBoard([...updatedBoard]);\r\n    }\r\n\r\n    const handleGenerate = () => {\r\n        setIsGenerating(true);\r\n        const newBoard = generate(dim, animateWallStep, setIsGenerating, setHasGenerated);\r\n        setBoard(newBoard);\r\n        setPlayerPos([-1,-1]);\r\n        setWin(false);\r\n    };\r\n\r\n    const handleStartGame = () => {\r\n        setPlayerPos([0,1]);\r\n        setWin(false);\r\n        setGameStarted(true);\r\n    };\r\n\r\n    const handleAutoSolve = () => {\r\n        autoSolve();\r\n    };\r\n\r\n    const autoSolve = () => {\r\n        setSolving(true);\r\n        let path = [[0,1]];\r\n        let visited = new Set();\r\n        const solveStep = () => {\r\n            if (path.length > 0) {\r\n                // get most recent space\r\n                let [row, col] = path[path.length-1];\r\n                // color explored spaces greem\r\n                board[row][col][0] = 2;\r\n                setBoard([...board]);\r\n                visited.add([row,col]);\r\n\r\n                // if reach end, color this path blue\r\n                if (row == board.length-1 && col == board.length-2) {\r\n                    console.log(\"autosolved\");\r\n                    path.forEach(([r,c]) => {\r\n                        board[r][c][0] = 3;\r\n                    });\r\n                    setSolving(false);\r\n                    setWin(true);\r\n                    setGameStarted(false);\r\n                    return;\r\n                }\r\n\r\n                let stepAdded = false;\r\n                const directions = [[1,0],[0,1],[-1,0],[0,-1]];\r\n                // check each direction (avoid double back)\r\n                for (let [dRow, dCol] of directions) {\r\n                    let newRow = row + dRow;\r\n                    let newCol = col + dCol;\r\n                    if (newRow >= 0 && newRow < board.length && newCol >= 0 && newCol < board.length\r\n                        && board[newRow][newCol][0] === 0 && !visited.has([newRow,newCol])) {\r\n                            path.push([newRow, newCol]);\r\n                            stepAdded = true;\r\n                            break;\r\n                        }\r\n                }\r\n                // backtrack if couldn't move forward\r\n                if (!stepAdded) {\r\n                    path.pop();\r\n                    return solveStep();\r\n                }\r\n                \r\n                setTimeout(solveStep, 10);\r\n            } else {\r\n                setSolving(false);\r\n            }\r\n        };\r\n        solveStep();\r\n    };\r\n\r\n    useEffect(() => {\r\n        const disableArrowKeys = (e) => {\r\n            if ([\"ArrowUp\",\"ArrowDown\",\"ArrowLeft\",\"ArrowRight\"].includes(e.key)) {\r\n                e.preventDefault();\r\n            }\r\n        };\r\n\r\n        if (gameStarted) {\r\n            window.addEventListener(\"keydown\", disableArrowKeys);\r\n        } else {\r\n            window.removeEventListener(\"keydown\", disableArrowKeys);\r\n        }\r\n\r\n        return () => {\r\n            window.removeEventListener(\"keydown\", disableArrowKeys);\r\n        };\r\n    }, [gameStarted]);\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"mazeBox\">\r\n                <h1>Maze Generator</h1>\r\n                <p>Using Randomized Kruskal's Algorithm</p>\r\n                <div className=\"genAndDimSlider\">\r\n                    {gameStarted ? (\r\n                        <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center' }}>\r\n                            <button className=\"autoSolve\" onClick={handleAutoSolve}>Auto Solve</button>\r\n                            <div>Use arrow keys to move player to bottom right</div>\r\n                        </div>\r\n                    ) : (\r\n                        <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center' }}>\r\n                            {isGenerating ? (\r\n                                /*<button className=\"speedUp\" onClick={handleSpeedUp}>Speed Up</button>*/\r\n                                <div className=\"genText\">Generating maze of size: {dim}...</div>\r\n                            ) : (\r\n                                <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center' }}>\r\n                                    <button className=\"startMaze\" onClick={handleGenerate}>Generate Maze</button>\r\n                                    <div className=\"dimSliderBox\">\r\n                                        <input\r\n                                            type=\"range\"\r\n                                            id=\"dimSlider\"\r\n                                            min=\"1\"\r\n                                            max=\"40\"\r\n                                            value={dim}\r\n                                            onChange={(e) => setDim(Number(e.target.value))}\r\n                                        />\r\n                                        <label htmlFor=\"dimSlider\">Size: {dim}</label>\r\n                                    </div>\r\n                                </div>\r\n                            )}\r\n                            \r\n                            {hasGenerated && !win && (\r\n                                <button className=\"startGame\" onClick={handleStartGame}>Start Game</button>\r\n                            )}\r\n                        </div>\r\n                    )}\r\n                    \r\n                </div>\r\n                {win && <div className=\"winMessage\">Maze solved!</div>}\r\n                <Maze board={board} playerPos={playerPos} setPlayerPos={setPlayerPos} setWin={setWin} setGameStarted={setGameStarted} gameStarted={gameStarted}/>\r\n                \r\n                <div className=\"kruskalText\">\r\n                    <h1>About Randomized Kruskal's Algorithm</h1>\r\n                    <pre>The Randomized Kruskal's Algorithm is a variation of Kruskal's \r\n                        <br/>Algorithm to find a minimum spanning tree of a graph. \r\n                        <br/>Kruskal's Algorithm is essentially:\r\n                        <br/>\r\n                        <br/>       1. Initialize a forest of single-vertex trees for each vertex\r\n                        <br/>          in input graph.\r\n                        <br/>       2. Sort edges of the input graph by weight\r\n                        <br/>       3. For each edge (in order of weight):\r\n                        <br/>           - If adding the edge would not create a cycle: \r\n                        <br/>              - Add the edge to the forest and merge the trees it connects\r\n                        <br/>\r\n                        <br/>The version of Kruskal's Algorithm used to create this maze does not use\r\n                        <br/>weights but instead applies a random order. randomized version applied to this maze goes like this: \r\n                        <br/>\r\n                        <br/>       1. Initialize the walls to separate single square cells. \r\n                        <br/>       2. Add all the walls to a single set and shuffle it. \r\n                        <br/>          Make a set for each cell containing only that cell.\r\n                        <br/>       3. For each wall in the set of walls:\r\n                        <br/>           - If the sets of adjacent spaces do not overlap: \r\n                        <br/>              - Make the wall a space and combine the sets of adjacent\r\n                        <br/>                spaces including the space just created\r\n                        <br/>\r\n                        <br/>In this application, the initial constuction of walls creates a graph\r\n                        <br/>of spaces (nodes) which can be connected by edges (walls). Each square's\r\n                        <br/>set represents the tree of spaces it is connected to. When we remove a wall, \r\n                        <br/>we are adding an edge between the sets of adjacent spaces. So by only\r\n                        <br/>removing a wall when the adjacent sets do not overlap, we are connecting\r\n                        <br/>portions of the maze while guaranteeing that there are no cycles. Once all\r\n                        <br/>the walls that can be removed have been, every edge that could have\r\n                        <br/>been added without creating a cycle was added and now there is one set\r\n                        <br/>that connects every space. Thus, we are left with a connected graph with no\r\n                        <br/>cycles or a spanning tree. In other words, any space can be reached starting\r\n                        <br/>from any other space, including the end square from the beginning square.\r\n\r\n                    </pre>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MazeApp;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}